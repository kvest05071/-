[< содержанию](./readme.md)

## Обычный workflow при работе с локальным репозитарием

***Git*** обладает необычайной легкостью в использовании не только как распределенная система контроля версий, но и в работе с локальными проектами. Давайте разберем обычный цикл — начиная с создания репозитария — работы разработчика ***git*** над собственным персональным проектом:

***mkdir git-demo***

***cd git-demo***

***git init***

***git add.***

***git commit -m «initial commit»***

***git branch new-feature***

***git checkout new-feature***

***git add.***

***git commit -m «Done with the new feature»***

***git checkout master***

***git diff HEAD new-feature***

***git merge new-feature***

***git branch -d new-feature***

***git log --since=«1 day»***



Разберем каждое из действий. 
1. Просто создаем рабочую директорию проекта.
2. Создаем репозитарий в директории. 
3. Индексируем все существующие файлы проекта (если, конечно, они вообще были). 
4. Создаем инициализирующий коммит. 
5. Новая ветка, 
6. Переключение в нее (можно сделать в один шаг командой ***git checkout -b new-feature***). 
   1. Далее, после непосредственной работы с кодом, индексируем внесенные изменения
   2. совершаем коммит
   3. Переключаемся в основную веткe
   4. Смотрим отличия между последним коммитом активной ветки и последним коммитом экспериментальной 
   5. Проводим слияние 
   6. И, если не было никаких конфликтов, удаляем ненужную больше ветку 
   7. Ну и на всякий случай оценим проведенную за последний день работу 

Почему именно так? Зачем отказываться от линейной модели? Хотя бы даже потому,
что у программиста появляется дополнительная гибкость: он может переключаться
между задачами (ветками); под рукой всегда остается «чистовик» — ветка
***master***; коммиты становятся мельче и точнее.

Источник: https://habr.com/ru/post/60347/